<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>姜悦的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="姜悦的博客">
<meta property="og:url" content="http://www.jiangyue0013.com/index.html">
<meta property="og:site_name" content="姜悦的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="姜悦的博客">
  
    <link rel="alternate" href="/atom.xml" title="姜悦的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">姜悦的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这世界唯一不变的事情就是这世界一直在改变。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.jiangyue0013.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-从Django部署中学到的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/从Django部署中学到的/" class="article-date">
  <time datetime="2019-07-08T09:14:10.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/从Django部署中学到的/">从Django部署中学到的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>修改pip的源</p>
<p>pip 的配置文件在 ~/.pip/pip.conf</p>
<p>文件内容如下：</p>
<pre><code>[global]

index-url = http://mirrors.tencentyun.com/pypi/simple

trusted-host = mirrors.tencentyun.com</code></pre><p>豆瓣源的网址是：</p>
<p><a href="http://pypi.doubanio.com/simple/" target="_blank" rel="noopener">http://pypi.doubanio.com/simple/</a></p>
<p>只需将</p>
<p>index-url = <a href="http://mirrors.tencentyun.com/pypi/simple" target="_blank" rel="noopener">http://mirrors.tencentyun.com/pypi/simple</a></p>
<p>trusted-host = mirrors.tencentyun.com</p>
<p>替换为：</p>
<p>Index-url =<a href="http://pypi.doubanio.com/simple/" target="_blank" rel="noopener">http://pypi.doubanio.com/simple/</a></p>
<p>trusted-host = pypi.doubanio.com</p>
<p>即可。</p>
<p>杀死进程</p>
<p>例子：</p>
<p>fuser -k 9090/tcp</p>
<p>上线typeidea 项目</p>
<p>我写的是一个django项目，使用uwsgi + nginx</p>
<p>因为上次上线时间久远，而且我也不了解nginx的配置文件怎么写。所以这次使用万能的重装大法，来上线这个博客网站。</p>
<p>输入：</p>
<pre><code>yum remove nginx</code></pre><p>卸载nginx</p>
<p>输入：</p>
<pre><code>rm -rf /etc/nginx/</code></pre><p>删除之前的配置文件</p>
<p>输入：</p>
<pre><code>yum install nginx</code></pre><p>安装nginx</p>
<p>输入：</p>
<pre><code>cd /etc/nginx/</code></pre><p>进入nginx 的配置文件夹</p>
<p>输入：</p>
<p>ll</p>
<p>可以看到如下文件</p>
<p><img src="/img/bVbuvaO" alt="图片描述"></p>
<p>输入：</p>
<p>systemctl nginx.service start</p>
<p>启动nginx服务，打开浏览器输入服务器的公网IP见到下面的界面证明安装成功。</p>
<p><img src="/img/bVbuvaP" alt="图片描述"></p>
<p>接下来安装uwsgi</p>
<p>输入：</p>
<p>pip3 install uwsgi</p>
<p>安装uwsgi</p>
<p>安装完成后测试uwsgi 是否安装成功</p>
<p>创建一个test.py 文件。文件内容如下：</p>
<p>def application(env, start_response):</p>
<pre><code>start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/htm/&apos;)])</code></pre><p>return [b’Hello World’]</p>
<p>然后输入：</p>
<p>uwsgi –http :8000 –wsgi-file test.py</p>
<p>打开浏览器，输入：主机IP:8000</p>
<p>看到：“Hello World“，证明运行成功。</p>
<p>配置uwsgi的ini文件</p>
<p>uwsgi有多种配置文件的格式比如ini、xml等</p>
<p>我使用的是ini</p>
<p>文件内容如下：</p>
<pre><code>[uwsgi]
socket = 127.0.0.1:9090
master = true
#vhost= true
#no-site=true
workers = 2
reload-mercy = 10
vacuum = true
max-requests = 1000
limit-as = 512
buffer-size = 30000
pidfile = /home/log_mysite/typeidea.pid
daemonize = /home/log_mysite/typeidea.log  # uwsgi的日志文件
chdir = /home/mysite/typeidea  # django 项目的根目录
wsgi-file = /home/mysite/typeidea/typeidea/wsgi.py #wsgi文件的路径</code></pre><p>配置nginx服务器的话 需要将下列内容增加到 nginx.conf 文件中</p>
<pre><code>server {
        listen 80;
        server_name typeidea;
        location / {
            include uwsgi_params;
            uwsgi_pass 127.0.0.1:9090;  # 要和usgi文件中 socket 的地址一致
            client_max_body_size 35m;
            }
        location /static/ {
            alias /home/mysite/typeidea/typeidea/static/;  # 静态文件路径
            }
        location /media/ {
            alias /home/mysite/typeidea/typeidea/media/;  # 保存文件时的媒体文件路径
            }
        }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/07/08/从Django部署中学到的/" data-id="cjxv157tm000cj4730re3f9ij" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/django/">django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-升级python版本和搭建环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/03/升级python版本和搭建环境/" class="article-date">
  <time datetime="2019-07-03T14:19:02.000Z" itemprop="datePublished">2019-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/03/升级python版本和搭建环境/">&#39;升级python版本和搭建环境&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>ModuleNotFoundError: No module named &apos;_contextvars&apos;</code></pre><p>由于上面这个错误我需要把我的Python版本从python3.7.2升级到3.7.3。<br>官网下载最新的python安装文件之后，双击选择repair即可升级。<br>成功之后可以在cmd中输入：<br>    python<br>查看新的python版本。结果如下证明升级成功。<br>    Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32<br>    Type “help”, “copyright”, “credits” or “license” for more information.<br>    &gt;&gt;&gt;<br>当然虚拟环境的python版本还是3.7.2。所以我们需要重新搭建虚拟环境。<br>我之前使用的虚拟环境是使用Virtualenv 生成的这次使用python自带的 venv 工具创建虚拟环境。<br>在此之前首先导出之前虚拟环境安装的库。<br>使用下面的命令导出：<br>    pip freeze &gt; requirements.txt<br>注意一定要在虚拟环境中执行这个命令。<br>执行之后可以在 requirements.txt 中查看安装的库。<br>接下来退出虚拟环境，使用下面的命令使用 python 自带的 venv 工具创建虚拟环境。<br>    python -m venv scrapy_env<br>其中 scrapy_env 是虚拟环境的名称，运行上面命令之后，可以看到一个 scrapy_env 的文件夹。进入此文件的 Scripts 文件夹执行：<br>    activate<br>即可激活虚拟环境。在虚拟环境中输入：<br>    python<br>可以看到 python 版本可以变为 3.7.3 。<br>然后执行下面命令：<br>    pip install -r requirements.txt<br>来安装之前虚拟环境中的库。<br>执行下面的命令：<br>    pip freeze<br>查看已经安装的包。如果和 requeirements.txt 文件中的一致证明安装成功。</p>
<p>但是我又遇到了一个新的错误：<br>    ERROR: Complete output from command python setup.py egg_info:<br>    ERROR: Please specify –curl-dir=/path/to/built/libcurl<br>    —————————————-<br>    ERROR: Command “python setup.py egg_info” failed with error code 10 in C:\Users\jiang\AppData\Local\Temp\piinstall-77v7t2r6\pycurl\</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/07/03/升级python版本和搭建环境/" data-id="cjxv157to000dj4734gob2ef3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-运行Django项目出现RuntimeError错误的解决方法。" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/02/运行Django项目出现RuntimeError错误的解决方法。/" class="article-date">
  <time datetime="2019-07-02T14:16:45.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/运行Django项目出现RuntimeError错误的解决方法。/">&#39;运行Django项目出现RuntimeError错误的解决方法。&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>运行Django项目出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: cryptography is required for sha256_password or caching_sha2_password</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cryptography</span><br></pre></td></tr></table></figure>

<p>安装cryptography即可解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/07/02/运行Django项目出现RuntimeError错误的解决方法。/" data-id="cjxv157th0008j47327g2lkk6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/django/">django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-八大排序算法使用python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/02/八大排序算法使用python实现/" class="article-date">
  <time datetime="2019-07-02T03:12:13.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/八大排序算法使用python实现/">&#39;八大排序算法使用python实现&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、冒泡排序</p>
<p>冒泡排序算法的运作如下：</p>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>以上节选自维基百科</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(numberlist):</span><br><span class="line">    length = len(numberlist)</span><br><span class="line">    for i in range(length):</span><br><span class="line">        for j in range(1, length - i):</span><br><span class="line">            if numberlist[j - 1] &gt; numberlist[j]:</span><br><span class="line">                numberlist[j], numberlist[j - 1] = numberlist[j - 1], numberlist[j]</span><br><span class="line">    return numberlist</span><br></pre></td></tr></table></figure>

<p>二、选择排序</p>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>以上节选自维基百科</p>
<p>代码实现：</p>
<pre><code>def findSmallest(arr):  # 用于查找出数组中最小的元素，返回最小元素的索引。
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if smallest &gt; arr[i]:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selectSort(arr):
    newArr = []
    while arr:
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr</code></pre><p>三、插入排序</p>
<p>步骤如下</p>
<p>从第一个元素开始，该元素可以认为已经被排序<br>取出下一个元素，在已经排序的元素序列中从后向前扫描<br>如果该元素（已排序）大于新元素，将该元素移到下一位置<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>将新元素插入到该位置后<br>重复步骤2~5<br>以上节选自维基百科</p>
<p>代码实现</p>
<pre><code>def insert_sort(data):
    for k in range(1, len(data)):
        cur = data[k]
        j = k
        while j &gt; 0 and data[j - 1] &gt; cur:
            data[j] = data[j - 1]
            j -= 1
        data[j] = cur
    return data</code></pre><p>四、希尔排序</p>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>以上节选自维基百科</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(numberlist):</span><br><span class="line">    length = len(numberlist)</span><br><span class="line">    gap = length // 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        for i in range(gap, length):</span><br><span class="line">            temp = numberlist[i]</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt;= gap and numberlist[j - gap] &gt; temp:</span><br><span class="line">                numberlist[j] = numberlist[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            numberlist[j] = temp</span><br><span class="line">        gap = gap // 2</span><br><span class="line">    return numberlist</span><br></pre></td></tr></table></figure>

<p>五、归并排序</p>
<p>原理如下（假设序列共有{\displaystyle n}个元素）：</p>
<p>将序列每相邻两个数字进行归并操作，形成{\displaystyle ceil(n/2)}个序列，排序后每个序列包含两/一个元素<br>若此时序列数不是1个则将上述序列再次归并，形成{\displaystyle ceil(n/4)}个序列，每个序列包含四/三个元素<br>重复步骤2，直到所有元素排序完毕，即序列数为1<br>以上节选自维基百科</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def  merge(left, right):</span><br><span class="line">    result = []</span><br><span class="line">    while left and right:</span><br><span class="line">        if left[0] &lt; right[0]:</span><br><span class="line">            result.append(left.pop(0))</span><br><span class="line">        else:</span><br><span class="line">            result.append(right.pop(0))</span><br><span class="line">    if left:</span><br><span class="line">        result += left</span><br><span class="line">    if right:</span><br><span class="line">        result += right</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(numberlist):</span><br><span class="line">    if len(numberlist) &lt;= 1:</span><br><span class="line">        return numberlist</span><br><span class="line">    mid = len(numberlist) // 2</span><br><span class="line">    left = numberlist[:mid]</span><br><span class="line">    right = numberlist[mid:]</span><br><span class="line"></span><br><span class="line">    left = merge_sort(left)</span><br><span class="line">    right = merge_sort(right)</span><br><span class="line">    return merge(left, right)</span><br></pre></td></tr></table></figure>

<p>六、快速排序</p>
<p>从数列中挑出一个元素，称为“基准”（pivot），<br>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。<br>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>以上节选自维基百科</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(array):</span><br><span class="line">        if len(array) &lt; 2:</span><br><span class="line">            return array</span><br><span class="line">        else:</span><br><span class="line">            pivot = array[0]</span><br><span class="line">            less = [i for i in array[1:] if i &lt;= pivot]</span><br><span class="line">            greater = [i for i in array[1:] if i &gt; pivot]</span><br><span class="line">            return quick_sort(less) + [pivot] + quick_sort(greater)</span><br></pre></td></tr></table></figure>

<p>七、堆排序</p>
<p>若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。</p>
<p>重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def heap_sort(numberlist):</span><br><span class="line">    length = len(numberlist)</span><br><span class="line">    def sift_down(start, end):</span><br><span class="line">        root = start</span><br><span class="line">        while True:</span><br><span class="line">            child = 2 * root + 1</span><br><span class="line">            if child &gt; end:</span><br><span class="line">                break</span><br><span class="line">            if child + 1 &lt;= end and numberlist[child] &lt; numberlist[child + 1]:</span><br><span class="line">                child += 1</span><br><span class="line">            if numberlist[root] &lt; numberlist[child]:</span><br><span class="line">                numberlist[root], numberlist[child] = numberlist[child], numberlist[root]</span><br><span class="line">                root = child</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">    </span><br><span class="line"># 创建最大堆</span><br><span class="line">    for start in range((length - 2) // 2, -1, -1):</span><br><span class="line">        sift_down(start, length - 1)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">    for end in range(length - 1, 0, -1):</span><br><span class="line">        numberlist[0], numberlist[end] = numberlist[end], numberlist[0]</span><br><span class="line">        sift_down(0, end - 1)</span><br><span class="line">    </span><br><span class="line">    return numberlist</span><br></pre></td></tr></table></figure>

<p>八、计数排序<br>以上节选自维基百科<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def counting_sort(numberlist, maxnumber):  # maxnumber为数组中的最大值</span><br><span class="line">    length = len(numberlist)  # 待排序数组长度</span><br><span class="line">    b = [0 for i in range(length)] # 设置输出序列，初始化为0</span><br><span class="line">    c = [0 for i in range(maxnumber+ 1)]  # 设置技术序列，初始化为0</span><br><span class="line">    for j in numberlist:</span><br><span class="line">        c[j] = c[j] + 1</span><br><span class="line">    for i in range(1, len(c)):</span><br><span class="line">        c[i] = c[i] + c[i - 1]</span><br><span class="line">    for j in numberlist:</span><br><span class="line">        b[c[j] - 1] = j</span><br><span class="line">        c[j] = c[j] - 1</span><br><span class="line">    return b</span><br></pre></td></tr></table></figure>

<p>本文章参考维基百科和八大排序算法python实现合辑</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/07/02/八大排序算法使用python实现/" data-id="cjxv157tj0009j473pimir6yw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Django中Queryset的使用（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/Django中Queryset的使用（一）/" class="article-date">
  <time datetime="2019-06-30T14:14:15.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/Django中Queryset的使用（一）/">&#39;Django中Queryset的使用（一）&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Queryset的使用"><a href="#Queryset的使用" class="headerlink" title="Queryset的使用"></a>Queryset的使用</h3><p>Queryset是懒加载的，部分支持链式调用。</p>
<p>支持链式调用的接口：</p>
<ul>
<li><p>all接口: 用于查询所有数据</p>
</li>
<li><p>filter接口: 根据条件进行过滤</p>
</li>
<li><p>exclude接口: 同filter，只是相反的逻辑</p>
</li>
<li><p>reverse接口: 把Queryset中的结果倒序排列</p>
</li>
<li><p>distinct接口: 用来进行去重查询</p>
</li>
<li><p>none接口: 返回空的Queryset</p>
</li>
</ul>
<p>不支持链式调用的接口：</p>
<ul>
<li><p>get接口：用于查询，存在返回对应的实例，不存在，则抛出DoesNotExist异常</p>
</li>
<li><p>create接口：直接创建一个Model对象</p>
</li>
<li><p>get_or_create接口：根据条件查找，如果没有查找到，就调用create创建</p>
</li>
<li><p>update_or_create接口：同get_or_create，只是用来做更新操作</p>
</li>
<li><p>count接口：用于返回Queryset有多少条记录</p>
</li>
<li><p>latest接口：用于返回最新一条记录，但需要在Model的Meta中定义：get_latest_by = &lt;用来排序的字段&gt;</p>
</li>
<li><p>earliest接口：同上，返回最早的一条记录</p>
</li>
<li><p>first接口：从当前Queryset记录中获取第一条</p>
</li>
<li><p>last接口：同上，获取最后一条</p>
</li>
<li><p>exists接口：返回True或者False，只需要判断Queryset是否有数据用这个接口最合适</p>
</li>
<li><p>bulk_create接口：同create，用来批量创建记录</p>
</li>
<li><p>in_bulk接口：批量查询</p>
</li>
<li><p>update接口： 用来根据条件批量更新记录</p>
</li>
<li><p>delete接口： 同update，这个接口是用来根据条件批量删除记录。update和delete都会出发Django的signal</p>
</li>
<li><p>values接口:当我们明确知道只需要返回某个字段的值，不需要Model实例时，可以使用</p>
</li>
<li><p>values_list接口：同values，但直接返回的是包含tuple的Queryset</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/30/Django中Queryset的使用（一）/" data-id="cjxv157t90003j473tpodlmni" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Queryset/">Queryset</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/django/">django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-我对Django中 froms使用的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/我对Django中 froms使用的理解/" class="article-date">
  <time datetime="2019-06-30T14:10:37.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/我对Django中 froms使用的理解/">我对 Django 中 froms 使用的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章谈一下我对 Django 中 forms的简单理解，确切的说像是一种代码的说明。</p>
<p>我觉得 Django 中的forms 就是view用与渲染成html语言的代码。用来帮助我们减少写html的工作量。</p>
<p>下面的代码就是本博客实现评论功能的forms。</p>
<pre><code>from django import forms
from .models import Comment

import mistune


class CommentForm(forms.ModelForm):
    nickname = forms.CharField(
        label=&apos;昵称&apos;,
        max_length=50,
        widget=forms.widgets.Input(
            attrs={&apos;class&apos;: &apos;form-control&apos;, &apos;style&apos;: &apos;width: 60%;&apos;}
        )
    )
    email = forms.CharField(
        label=&apos;Email&apos;,
        max_length=50,
        widget=forms.widgets.Input(
            attrs={&apos;class&apos;: &apos;form-control&apos;, &apos;style&apos;: &apos;width: 60%;&apos;}
        )
    )

    website = forms.CharField(
        label=&apos;网站&apos;,
        max_length=100,
        widget=forms.widgets.URLInput(
            attrs={&apos;class&apos;: &apos;form-control&apos;, &apos;style&apos;: &apos;width: 60%;&apos;}
        )
    )

    content = forms.CharField(
        label=&apos;内容&apos;,
        max_length=500,
        widget=forms.widgets.Textarea(
            attrs={&apos;row&apos;: 6, &apos;class&apos;: &apos;form-control&apos;}
        )
    )

    def clean_content(self):
        content = self.cleaned_data.get(&apos;content&apos;)
        if len(content) &lt; 10:
            raise forms.ValidationError(&apos;内容长度太短了！&apos;)
        content = mistune.markdown(content)
        return content

    class Meta:
        model = Comment
        fields = [&apos;nickname&apos;, &apos;email&apos;, &apos;website&apos;, &apos;content&apos;]</code></pre><p>下面我一段一段的解释一下：</p>
<pre><code>from django import forms  # 导入 forms 模块
from .models import Comment  # 导入Comment模型，评论的需要填写的字段均来自于此

import mistune  # 导入 mistune 模块，为了使评论支持markdown语法
class CommentForm(forms.ModelForm):  # 我们写的CommentForm 继承了forms模块中的ModelForm类
    nickname = forms.CharField(  # 这里我们对模型中的每一个字段对应的表单进行设置
        label=&apos;昵称&apos;,  # 这里对应html label标签中的文字
        max_length=50,  # 设置表单中填写的最大长度
        widget=forms.widgets.Input(  # 设置html中的标签类型为input
            attrs={&apos;class&apos;: &apos;form-control&apos;, &apos;style&apos;: &apos;width: 60%;&apos;}  # 规定input的样式
        )
    )

def clean_content(self):  # 判断评论长度和表单数据验证
        content = self.cleaned_data.get(&apos;content&apos;)
        if len(content) &lt; 10:
            raise forms.ValidationError(&apos;内容长度太短了！&apos;)
        content = mistune.markdown(content)
        return content

class Meta:  # 规定类的元数据
        model = Comment  
        fields = [&apos;nickname&apos;, &apos;email&apos;, &apos;website&apos;, &apos;content&apos;]</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/30/我对Django中 froms使用的理解/" data-id="cjxv157td0005j473x20d58dd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/django/">django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web开发技术栈清单-Python基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/Web开发技术栈清单-Python基础篇/" class="article-date">
  <time datetime="2019-06-30T14:06:57.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/Web开发技术栈清单-Python基础篇/">Web开发技术栈清单-Python基础篇&#39;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>问题答案由本人整理</p>
<hr>
<h4 id="1-基础语法是否熟悉？介绍一下"><a href="#1-基础语法是否熟悉？介绍一下" class="headerlink" title="1.基础语法是否熟悉？介绍一下"></a>1.基础语法是否熟悉？介绍一下</h4><p>Python和其他语言最大的区别就是使用行和缩进，而不是大括号（{}）或者分号（;）来控制类、函数或者逻辑判断。Python使用换行来表示语句的结束。但同时可以用左斜杠（\）将一行语句分成多行。Python 使用单引号（’）、双引号（”)和三引号（’’’或”””）来表示字符串。其中单引号和双引号的区别不大，字符串中含有单引号或者双引号时需用转义符号（\）或双引号及单引号包裹即可。三引号则支持字符串换行。</p>
<h4 id="2-有哪些关键字？解释其作用"><a href="#2-有哪些关键字？解释其作用" class="headerlink" title="2.有哪些关键字？解释其作用"></a>2.有哪些关键字？解释其作用</h4><p>Python中的关键字可以在Python交互模式中输入下面代码查看：</p>
<pre><code>import keyword
keyword.kwlist</code></pre><ul>
<li><p>False 表示布尔类型中的假</p>
</li>
<li><p>None </p>
</li>
<li><p>True</p>
</li>
<li><p>and 表示逻辑 ’与‘</p>
</li>
<li><p>as 用于类型转换</p>
</li>
<li><p>assert 断言，用于判断变量或者条件表达式的值是否为真</p>
</li>
<li><p>async</p>
</li>
<li><p>await</p>
</li>
<li><p>break 用于中止循环，brea后的语句不会执行，跳出分支或者循环</p>
</li>
<li><p>class 用于创建类</p>
</li>
<li><p>continue 用于继续下一次循环</p>
</li>
<li><p>def 用于定义函数或方法</p>
</li>
<li><p>del 用于list列表操作，删除一个或多个元素</p>
</li>
<li><p>elif 用于定义if中的其他分支的操作</p>
</li>
<li><p>else 用于定义if语句中所有条件都不满足时执行的操作</p>
</li>
<li><p>except except包含捕获异常后的操作代码块，与try,finally结合使用</p>
</li>
<li><p>finally 用于异常语句，出现异常后，始终要执行finally，包含的代码块，与try，except结合使用</p>
</li>
<li><p>for 用于for循环语句</p>
</li>
<li><p>from 导入模块 用 import … 或from … import</p>
</li>
<li><p>fwrom</p>
</li>
<li><p>global 用于声明全局变量</p>
</li>
<li><p>if 用于if语句</p>
</li>
<li><p>import 用于导入模块</p>
</li>
<li><p>in 用于判断变量是否在序列中</p>
</li>
<li><p>is 用于判断两个对象是否时同一对象</p>
</li>
<li><p>lambda 定义匿名变量</p>
</li>
<li><p>nonlocal</p>
</li>
<li><p>not 表示逻辑’非‘</p>
</li>
<li><p>or 表示逻辑’或‘</p>
</li>
<li><p>pass 空的类、方法和函数的占位符。</p>
</li>
<li><p>raise 用于异常抛出操作</p>
</li>
<li><p>return 用于函数的返回值</p>
</li>
<li><p>try 用与捕捉异常</p>
</li>
<li><p>while 用于控制循环，允许重复执行一个代码块</p>
</li>
<li><p>with 用于简化python中的语法 <a href="https://zhuanlan.zhihu.com/p/32122124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32122124</a></p>
</li>
<li><p>yield 用于函数依此返回函数值 <a href="https://zhuanlan.zhihu.com/p/32178981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32178981</a></p>
</li>
</ul>
<h4 id="3-有哪些内置方法？解释其作用"><a href="#3-有哪些内置方法？解释其作用" class="headerlink" title="3. 有哪些内置方法？解释其作用"></a>3. 有哪些内置方法？解释其作用</h4><ul>
<li><p>abs(x) # 返回x的绝对值</p>
</li>
<li><p>all(x) # x列表或可迭代数据全部为真才为真（非0即为真）</p>
</li>
<li><p>any(x) # x列表或可迭代数据有一个为真即为真</p>
</li>
<li><p>ascii(x) # 和repr()一样把x对象转换成ascii字符串对象打印出来</p>
</li>
<li><p>bin(x) # 把十进制转换为二进制</p>
</li>
<li><p>bool(x) # 判断x是否为真（非空即为真）</p>
</li>
<li><p>bytes() # 把字符转换成字节，使用时必须加上编码如 a=bytes(‘abcde’, encoding=’utf-8’)字符串不可被修改，所以二进制的字节也是不可被修改，如被切换或替换只是生成了一个新串，原始字符串不会被修改。</p>
</li>
<li><p>bytearray() # 可修改的二进制字节格式，它时以array方式进行修改</p>
</li>
<li><p>callable(x) # 判断对象是否可被调用</p>
</li>
<li><p>chr(x) # 返回ascii码对应的字符</p>
</li>
<li><p>ord(x) # 返回字对应的ascii码</p>
</li>
<li><p>compible() # 将字符串转化为代码进行执行</p>
</li>
<li><p>dict() # 字典</p>
</li>
<li><p>dir() # 查看参数有什么方法可用</p>
</li>
<li><p>divmode(x,y) # 除完返回商和余数的元组</p>
</li>
<li><p>eval() # 把字符串变字典，也可把简单的数学算法进行计算，若像斐波那契那样的算法就需要采用exec()方法</p>
</li>
<li><p>exec()</p>
</li>
<li><p>filter() # 用于数据过滤</p>
</li>
<li><p>lambda() # 匿名函数，lambda 只能处理简单的数学公式，最复杂只能到三元运算</p>
</li>
<li><p>map() # 对传入的每个值进行处理，再把原来的结果覆盖掉</p>
</li>
<li><p>reduce() # 在Python2中可以直接使用reduce，在Python3中需要引用functools</p>
</li>
<li><p>reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
</li>
<li><p>set() # 集合set()函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p>
</li>
<li><p>frozenset() # 不可变的集合</p>
</li>
<li><p>globals() # globals()函数会以字典类型返回当前位置的全部全局变量。</p>
</li>
<li><p>hash() #hash()用于获取取一个对象（字符串或者数值等）的哈希值。</p>
</li>
<li><p>hex() # 用于将10进制整数转换成16进制，以字符串形式表示。</p>
</li>
<li><p>locals(x) # locals() 函数会以字典类型返回当前位置的全部局部变量。对于函数, 方法, lambda 函式, 类, 以及实现了 <strong>call</strong> 方法的类实例, 它都返回 True。</p>
</li>
<li><p>max() # 返回字符串中最大的字母，或数组中的最大值。</p>
</li>
<li><p>min() # 返回字符串中最小的字母，或数组中的最小值。</p>
</li>
<li><p>object() # 在Python中一切皆为对象</p>
</li>
<li><p>oct() # 将一个数字转化为八进制</p>
</li>
<li><p>pow(x,y) # 返回x的y次方 的值。</p>
</li>
<li><p>reversed(seq) # 返回一个反转的迭代器。</p>
</li>
<li><p>round() # 返回浮点数x的四舍五入值。</p>
</li>
<li><p>sorted() # 对所有可迭代的对象进行排序操作。</p>
</li>
</ul>
<h4 id="4-解释一下什么是动态语言？动态强类型是指什么？"><a href="#4-解释一下什么是动态语言？动态强类型是指什么？" class="headerlink" title="4.解释一下什么是动态语言？动态强类型是指什么？"></a>4.解释一下什么是动态语言？动态强类型是指什么？</h4><p>动态语言是一类在运行时可以改变其结构的语言：比如新的函数、对象、甚至代码都可以被引进，已有的函数可以被删除或是其他结构上的变化，<br>动态强类型要分成两部分理解，一部分是动态类型，另一部分就是强类型。<br>动态类型语言就是在运行时，确定类型的语言。即编译时月类型无关。一般在变量使用之前不需要声明变量类型，而变量的类型通常是有被赋值的值的类型决定。<br>强类型语言就是强制类型定义的语言。也就是说，一旦一个白能量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。<br>强类型定义语言是类型安全的语言。</p>
<h4 id="5-是否有编码规范的概念？采用的是那种编码规范"><a href="#5-是否有编码规范的概念？采用的是那种编码规范" class="headerlink" title="5.是否有编码规范的概念？采用的是那种编码规范"></a>5.是否有编码规范的概念？采用的是那种编码规范</h4><p>我理解的代码规范就是类似操作指南，最简单的就是变量的命名方式。对于个人来说使用好的编码规范可以提高自己代码的可读性。对于团队而言可以提高团队合作的效率、降低维护成本。<br>Python 中最有名的编码规范就是PEP 8-Python<br>Python PEP-8编码风格指南中文版</p>
<h4 id="6-解释一下深拷贝和浅拷贝"><a href="#6-解释一下深拷贝和浅拷贝" class="headerlink" title="6.解释一下深拷贝和浅拷贝"></a>6.解释一下深拷贝和浅拷贝</h4><p>深拷贝需要导入copy模块，使用deepcopy()</p>
<pre><code>b = copy.deepcopy(a)</code></pre><p>a和b完全拷贝了父对象和及其子对象，两者是完全独立的</p>
<p>浅拷贝使用copy</p>
<pre><code>b = a.copy()</code></pre><p>a和b 是独立的对象，但他们的子对象还是指向同一对象（相当于引用）</p>
<h4 id="7-lambda的用法及其作用"><a href="#7-lambda的用法及其作用" class="headerlink" title="7.lambda的用法及其作用"></a>7.lambda的用法及其作用</h4><p>下面是一个lambda的例子：</p>
<pre><code>g = lambda x:x+1</code></pre><p>lamdba 定义了一个匿名函数，例子中的x为入口参数， x+1为函数体。如果用函数表示的话 ：</p>
<pre><code>def g(x):
    return x+1</code></pre><p>lamdba 简化了函数定义的书写形式。lamdba的作用就是减少了单行函数的定义。</p>
<h4 id="8-解释一下闭包及其作用"><a href="#8-解释一下闭包及其作用" class="headerlink" title="8.解释一下闭包及其作用"></a>8.解释一下闭包及其作用</h4><p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>
<p>闭包的作用就是有一些功能需要重用但不足以定义为类的行为就可以使用闭包。闭包会比类占用更少的资源。装饰器就是闭包的一个应用，除此之外闭包还可以用于封装。</p>
<p>9.实现一个简单的装饰器，用来对某个函数的结果进行缓存</p>
<pre><code>import functools
import time


CACHE = {}


def cache_it(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        key = repr(*args, **kwargs)
        try:
            result = CACHE[key]
        except KeyError:
            resuslt = func(*args, **kwargs)
            CAHE[key] = result
        return result
    return inner


import functools import time CACHE = {} def cache_it(func): @functools.wraps(func) def inner(*args, **kwargs): key = repr(*args, **kwargs) try: result = CACHE[key] except KeyError: resuslt = func(*args, **kwargs) CAHE[key] = result return result return inner</code></pre><p>10.Python中集中容器类型的差别及使用场景有哪些？</p>
<p>11.列表推导式的使用和场景有哪些？</p>
<p>12.介绍一下yield的用法</p>
<p>13.常见的内置库有哪些？具体说明它们的用法</p>
<p>14.介绍一下你了解的 magic method （魔术方法）及其作用</p>
<p>15.解释一下面向对象的概念及其在编程中的作用</p>
<p>16.如何实现单例模式？</p>
<p>17.如何对python对象进行序列化？</p>
<p>18.是否能够熟练编写多线程和多进程程序？</p>
<p>19.使用socke编写一个简单的HTTP服务器，成功返回success即可</p>
<p>20.如何理解Python中的GIL？这对我们的日常开发有什么影响？</p>
<p>21.解释一下协程、线程和进程之间的差别</p>
<p>引用来源：</p>
<p><a href="https://segmentfault.com/a/1190000004461404" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004461404</a></p>
<p><a href="https://foofish.net/python-closure.html" target="_blank" rel="noopener">https://foofish.net/python-closure.html</a></p>
<p><a href="https://www.cnblogs.com/evening/archive/2012/03/29/2423554.html" target="_blank" rel="noopener">https://www.cnblogs.com/evening/archive/2012/03/29/2423554.html</a></p>
<p><a href="https://kdboy.iteye.com/blog/407572" target="_blank" rel="noopener">https://kdboy.iteye.com/blog/407572</a></p>
<p><a href="http://www.voidcn.com/article/p-uozlkadx-vt.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-uozlkadx-vt.html</a></p>
<p><a href="https://blog.csdn.net/zxr15709447338/article/details/80872389" target="_blank" rel="noopener">https://blog.csdn.net/zxr15709447338/article/details/80872389</a></p>
<p>python关键字详解 - 削微寒 - 博客园</p>
<p>Python3 基础语法 | 菜鸟教程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/30/Web开发技术栈清单-Python基础篇/" data-id="cjxv157uq0016j473a5ye00nl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/django/">django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-1：两数之和" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/Leetcode-1：两数之和/" class="article-date">
  <time datetime="2019-06-30T13:34:24.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/Leetcode-1：两数之和/">Leetcode 1：两数之和</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。  </p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p><strong>方法1，暴力解法。</strong></p>
<p>直接每一个元素都与自己之前的元素相加看是否有目标值，有就输出。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n = len(nums)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if nums[i] + nums[j] == target:</span><br><span class="line">                    target_num = [i,j]</span><br><span class="line">                    return target_num</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>时间消耗和空间消耗如下：</p>
<p>执行用时: 4500 ms, 在Two Sum的Python3提交中击败了32.72% 的用户</p>
<p>内存消耗: 7.3 MB, 在Two Sum的Python3提交中击败了85.58% 的用户</p>
<p><strong>方法2，使用enumerate函数</strong></p>
<p>查看评论使用enumerate 函数效率更高。</p>
<p>enumerate函数可以将一个数组转化为一个key从开始，值为数组对应元素的字典。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not nums:</span><br><span class="line">            return None</span><br><span class="line">            d = dict()</span><br><span class="line">        for i,item in enumerate(nums):</span><br><span class="line">            tmp = target – item</span><br><span class="line">            if tmp in d:</span><br><span class="line">                return [i, d[tmp]]</span><br><span class="line">                d[item] = i</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>时间消耗和空间消耗如下：</p>
<p>执行用时: 44 ms, 在Two Sum的Python3提交中击败了99.77% 的用户</p>
<p>内存消耗: 7.9 MB, 在Two Sum的Python3提交中击败了46.97% 的用户</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/30/Leetcode-1：两数之和/" data-id="cjxv157tb0004j473v9gdqyut" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《算法图解》第四章第一节练习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/《算法图解》第四章第一节练习/" class="article-date">
  <time datetime="2019-06-13T11:36:11.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/《算法图解》第四章第一节练习/">《算法图解》第四章第一节练习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###4.1请编写前述sum函数的代码。</p>
<pre><code>def diy_sum(arr):
if not arr:
    return 0
elif len(arr) == 1:
    return arr[0]
else:
    return arr.pop(0) + diy_sum(arr)


arr = [1, 2, 3]
print(diy_sum(arr))</code></pre><p>###4.2编写一个递归函数来计算列表包含的元素数。<br>    def count_elements(list):<br>    if not list:<br>        return None<br>    elif len(list) == 1:<br>        return 1<br>    else:<br>        return 1 + count_elements(list[1:])</p>
<pre><code>list = [1, 2, 3]
print(count_elements(list))</code></pre><p>###4.3找出列表中最大的数字<br>def bigger(int1, int2):<br>    if int1 &gt;= int2:<br>        return int1<br>    else:<br>        return int2</p>
<p>def find_biggest(list):<br>    if not list:<br>        return None<br>    elif len(list) == 1:<br>        return list[0]<br>    elif len(list) == 2:<br>        return bigger(list[0], list[1])<br>    else:<br>        return bigger(list[0], find_biggest(list[1:]))</p>
<pre><code>list = [1, 5, 3, 2]
print(find_biggest(list))</code></pre><p>###4.4 还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗？<br>    def binary_search_basic(list, target, low, high):<br>    if low &gt; high:<br>        return None<br>    else:<br>        mid = int((low + high) / 2 + 0.5)<br>        guess = list[mid]<br>        if guess == target:<br>            return mid<br>        elif guess &gt; target:<br>            high = mid - 1<br>            return binary_search_basic(list, target, low, high)<br>        else:<br>            low = mid + 1<br>            return binary_search_basic(list, target, low, high)</p>
<pre><code>def binary_search_dc(list, target):
    return binary_search_basic(list, target, 0, len(list) - 1)

list = [1, 2, 3, 4, 5]
target = 3
print(binary_search_dc(list, target))</code></pre><p>参考：<br><a href="https://blog.csdn.net/XIAOZHI0999/article/details/81298573" target="_blank" rel="noopener">https://blog.csdn.net/XIAOZHI0999/article/details/81298573</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/13/《算法图解》第四章第一节练习/" data-id="cjxv157t40001j473awl8ql91" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-初识Spalash" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/12/初识Spalash/" class="article-date">
  <time datetime="2019-06-12T04:15:11.000Z" itemprop="datePublished">2019-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/12/初识Spalash/">初识Spalash</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>输入下面命令运行splash：</p>
<pre><code>docker run -p 8050:8050 scrapinghub/splash</code></pre><p>一个splash的基本实例：</p>
<pre><code>function main(splash, args)
    splash:go(&quot;http://www.baidu.com&quot;)
    splash:wait(0.5)
    lcoal title = splash:evaljs(&quot;document.title&quot;)
    return {title=title}
end</code></pre><p>将上面实例复制到 localhost:8050 的代码编辑区域，并将网址设为 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p>
<p>点击Render me！返回 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 的title</p>
<p>我们在这里定义的方法名称为main()，这个名称是固定的，Splash会根据这个名字执行。</p>
<ul>
<li>入口及返回值</li>
</ul>
<p>该方法的返回值既可以是字典形式，也可以是字符串形式，最后都会转化为Splash HTTP Response。</p>
<ul>
<li>异步处理</li>
</ul>
<p>Splash支持异步处理，但是这里没有显式指明回调方法，其回调实在Splash内部完成的。</p>
<p>示例如下：</p>
<pre><code>function main(splash, args)
    local example_urls = {&quot;www.baidu.com&quot;, &quot;www.taobao.com&quot;, &quot;www.zhihu.com&quot;}
    local urls = args.urls or example_urls
    local results  = {}
    for index, url in ipairs(urls) do
        local ok, reason = splash:go(&quot;http://&quot; .. url)
        if ok then
            splash:wait(2)
            results[url] = splash:png()
        end
    end
    return results
end</code></pre><p>上面实例运行结果为，三个网站的的截图。<br>在脚本内调用的wait()方法类似与sleep()。其参数为等待的秒数。</p>
<p>“..”为拼接字符串。</p>
<h3 id="Splash对象属性"><a href="#Splash对象属性" class="headerlink" title="Splash对象属性"></a>Splash对象属性</h3><ul>
<li>args</li>
</ul>
<p>该属性可以获取加载时配置的参数，比如URL，</p>
<p>如果为GET请求，它还可以获取GET请求参数；</p>
<p>如果为POST请求，它可以获取表单提交的数据。</p>
<p>Splash也支持使用第二个参数直接作为args，例如：</p>
<pre><code>function main(spalsh, args)
    local url = args.url
end</code></pre><p>这里第二个参数args就相当于splash.args属性，以上代码等价于：<br>    function main(spalsh)<br>        local url = splash.args.url<br>    end</p>
<ul>
<li>js_enable</li>
</ul>
<p>这个属性是Splash的JavaScript执行开关，可以将其配置为true或false来控制是否执行JavaScript代码，默认为true.</p>
<p>一般不用设置此属性，默认开启。</p>
<ul>
<li>resource_timeout</li>
</ul>
<p>顾名思义，此属性设置加载的超时时间，单位为秒。如果设置为0或者nil(类似python中的None)，代表不检测超时。</p>
<p>此属性用于加载速度较慢的情况，避免给一直等待，超过时间无响应，直接抛出异常忽略即可。</p>
<ul>
<li>image_enable</li>
</ul>
<p>顾名思义，设置图片是否加载，默认情况加载。禁用之后可以节省网络流量并提高加载速度。</p>
<p>注意，禁用图片加载可能会影响JavaScript渲染。因为禁用图片加载后，它的外层DOM节点的高度会发生变化，进而影响</p>
<p>DOM节点的位置。若JavaScript对图片节点有操作的话，其执行就会有影响。</p>
<p>初次之外Splash使用了缓存，一开始缓存了图片，然后禁用了图片加载。再进行加载图片还会出现，此时重启Splash即可</p>
<p>。</p>
<ul>
<li>plugins_enable</li>
</ul>
<p>此属性控制浏览器插件（如Flash插件）是否开启。默认false，不开启。</p>
<ul>
<li>scroll_position</li>
</ul>
<p>通过设置此属性来控制页面上下或左右滚动。<br>示例如下：</p>
<pre><code>function main(splash, args)
    assert(splash:go(&quot;https://www.taobao.com&quot;))
    splash.scroll_position = {y=400}
    return {png = splash:png()}
end</code></pre><p>这样我们可以控制页面向下滚动400像素。</p>
<h3 id="Splash对象方法"><a href="#Splash对象方法" class="headerlink" title="Splash对象方法"></a>Splash对象方法</h3><ul>
<li>go()</li>
</ul>
<p>该方法用来请求某个链接，也可以模拟GET和POST请求，同时支持传入请求头、表单等数据，其用法如下：</p>
<pre><code>ok, reason = splash:go{url, baseurl=nil, http_method=&quot;GET&quot;, body=nil, formdata=nil}</code></pre><p>其参数说明如下：</p>
<ol>
<li><p>url：请求的URL。</p>
</li>
<li><p>baseurl：可选参数，默认为空，表示资源加载相对路径。</p>
</li>
<li><p>headers：可选参数，默认为空，表示请求头。</p>
</li>
<li><p>http_method：可选参数，默认为GET，同时支持POST。</p>
</li>
<li><p>body：可选参数，默认为空，发POST请求时的表单数据，使用的Content-type为application/json。</p>
</li>
<li><p>formdata：可选参数，默认为空，POST请求时的表单数据，使用的Content-type为application/x-www-form-urlencoded</p>
</li>
</ol>
<p>该方法的返回结果是结果ok和原因reason的组合，如果ok为空，代表网页加载出现了错误，此时reason变量包含了错误的原因，否则证明页面加载成功。</p>
<p>示例如下：</p>
<pre><code>function main(splash, args)
    local ok, reason = splash:go{&quot;http://httpbin.org/post&quot;, http_method=&quot;POST&quot;, body=&quot;name=Germy&quot;}
    if ok then
        return splash:html()
    end
end</code></pre><ul>
<li>wait()</li>
</ul>
<p>此方法可以控制页面等待时间使用方法如下：<br>ok, reason = splash:wait(time, cancel_on_redirect=false, cancel_on_error=true)</p>
<p>参数说明如下：</p>
<ol>
<li>time：等待的秒数。</li>
<li>cancel_on_redirect：可选参数默认为false，表示如果发生重定向就停止等待，并返回重定向的结果。</li>
<li>cancel_on_error：可选参数，默认为false，表示如果发生了加载错误，就停止等待。</li>
</ol>
<p>返回结果也是ok和reason的组合。</p>
<ul>
<li>jsfunc()</li>
</ul>
<p>此方法可以直接调用JavaScript定义的方法，但是所调用的方法需要用双中括号包围，这相当于实现了JavaScript方法到Lua脚本的转换。</p>
<ul>
<li>evaljs()</li>
</ul>
<p>此方法可以执行JavaScript代码并返回最后一条JavaScript语句的返回结果，使用方法如下：</p>
<pre><code>result = splash:evaljs(js)</code></pre><ul>
<li>runjs()</li>
</ul>
<p>此方法可以执行JavaScript代码，它与evaljs()的功能类似，但是更偏向于执行某些动作或声明某些方法。</p>
<ul>
<li>autoload()</li>
</ul>
<p>此方法可以设置每个页面访问时自动加载的对象，使用发放如下：</p>
<pre><code>ok, reason = splash:autoload{source_or_url, source=nil, url=nil}</code></pre><p>参数说明如下：</p>
<ol>
<li>source_or_url：JavaScript代码或者JavaScript库链接。</li>
<li>source：JavaScript代码</li>
<li>url：JavaScript库链接</li>
</ol>
<p>此方法只负责加载JavaScript代码或库，不执行任何操作。执行操作的话，需要调用evaljs()或runjs()方法。</p>
<ul>
<li>call_later()</li>
</ul>
<p>此方法可以通过设置定时任务和延迟时间来实现任务延时执行，并且可以在执行前通过cancel()方法重新执行定时任务。</p>
<p>示例如下：</p>
<pre><code>function main(splash, args)
    local snapshots = {}
    local timer = splash:call_later(function()
        snapshots[&quot;a&quot;] = splash:png()
        splash:wait(1.0)
        snapshots[&quot;b&quot;] = splash:png()
    end, 0.2)
    splash:go(&quot;https://www.taobao.com&quot;)
    splash:wait(3.0)
    return snapshots
end</code></pre><ul>
<li>http_get()</li>
</ul>
<p>此方法可以模拟发送HTTP的GET请求，使用方法如下：</p>
<pre><code>response = splash:http_get{url, headers=nil, follow_redirects=true}</code></pre><p>参数说明如下：</p>
<ol>
<li>url：请求URL</li>
<li>headers：可选参数，默认为空，请求头。</li>
<li>follow_redirects：可选参数，表示是启动自动重定向，默认为true。</li>
</ol>
<ul>
<li>http_post()</li>
</ul>
<p>此方法用来模拟发送POST请求，使用方法如下：</p>
<pre><code>response = splash:http_post{url, headers=nil, follow_redirects=true, body=nil}</code></pre><p>参数说明如下：</p>
<ol>
<li>url：请求URL。</li>
<li>headers：可选参数，默认为空，请求头。</li>
<li>follow_redrects：可选参数，表示是否启动自动重定向，默认为true</li>
<li>body：可选参数，即表单数据，默认为空</li>
</ol>
<ul>
<li>set_content()</li>
</ul>
<p>此方法用来设置页面的内容，示例如下：</p>
<pre><code>function main(splash, args)
    assert(splash:set_content(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;))
    return splash:png()
end</code></pre><ul>
<li>html()</li>
</ul>
<p>此方法用来获得网页的源代码</p>
<ul>
<li>png()</li>
</ul>
<p>此方法用来获取PNG格式的网页截图。</p>
<ul>
<li>jpeg()</li>
</ul>
<p>此方法用来获取JPEG格式的网页截图。</p>
<ul>
<li>har()</li>
</ul>
<p>此方法用来获得页面加载过程描述</p>
<ul>
<li>url()</li>
</ul>
<p>此方法可以获取当前正在访问的URL</p>
<ul>
<li>get_cookies()</li>
</ul>
<p>此方法可以获取当前页面的Cookies。</p>
<ul>
<li>add_cookies()</li>
</ul>
<p>此方法可以为当前页面添加Cookies。</p>
<ul>
<li>clear_cookies()</li>
</ul>
<p>此方法可以清除所有的Cookies。</p>
<ul>
<li>get_viewport_size()</li>
</ul>
<p>此方法可以获取当前浏览器页面的大小。</p>
<ul>
<li>set_viewport_size()</li>
</ul>
<p>此方法可以设置当前浏览器页面的大小</p>
<ul>
<li>set_viewport_full()</li>
</ul>
<p>此方法可以设置浏览器全屏显示</p>
<ul>
<li>set_uer_agent()</li>
</ul>
<p>此方法可以设置浏览器的User-Agent。</p>
<ul>
<li>set_custom_headers()</li>
</ul>
<p>此方法可以设置请求头</p>
<ul>
<li>select()</li>
</ul>
<p>该方法可以选中符合条件的第一个节点，如果有多个节点符合条件，则只会返回一个，其参数时CSS选择器。</p>
<ul>
<li>select_all()</li>
</ul>
<p>此方法可以选中所有符合条件的节点，其参数是CSS选择器。</p>
<ul>
<li>mouse_click()</li>
</ul>
<p>此方法可以模拟鼠标点击操作，传入的参数为坐标值的x 和y。此外，也可以直接选中某个节点，然后调用此方法。</p>
<h3 id="Splash-API调用"><a href="#Splash-API调用" class="headerlink" title="Splash API调用"></a>Splash API调用</h3><p>与python结合调用。</p>
<ul>
<li><p>render.html<br>此接口用于获取JavaScript渲染的页面的HTML代码，接口地址就是Splash的运行地址加此接口名称，<br>例如 :</p>
<p>  <a href="http://localhost:8050/render.html?url=https://www.baidu.com" target="_blank" rel="noopener">http://localhost:8050/render.html?url=https://www.baidu.com</a></p>
</li>
</ul>
<p>我们给此接口传递了一个url参数来指定渲染的URL，返回结果即页面渲染后的源代码。</p>
<ul>
<li>render.png</li>
</ul>
<p>此接口可以获取网页截图，通过width和heigh来控制宽高，返回PNG格式的图片二进制数据。示例如下：</p>
<pre><code>curl http://localhost:8050/rnder.png?url=https://www.taobao.com&amp;wait=5&amp;width=1000&amp;height=700</code></pre><ul>
<li>render.jpeg</li>
</ul>
<p>此接口接口返回jpeg格式的网页截图。参数quality用来设置图片质量。</p>
<ul>
<li>render.har</li>
</ul>
<p>此接口用于获取页面加载的HAR数据，示例如下：</p>
<pre><code>curl http://localhost:8050/render.har?url=https://www.jd.com&amp;wait=5</code></pre><ul>
<li>render.json</li>
</ul>
<p>此接口包含了前面接口的所有功能，返回结果是JSON格式。</p>
<ul>
<li>execute</li>
</ul>
<p>此接口是最为强大的接口，实现了与Lua脚本的对接。</p>
<h3 id="Splash负载均衡设置"><a href="#Splash负载均衡设置" class="headerlink" title="Splash负载均衡设置"></a>Splash负载均衡设置</h3><p>负载均衡的目的就是为了多个服务器分担压力。<br>假设四台服务器哦IP地址为：</p>
<ul>
<li>127.0.0.1</li>
<li>127.0.0.2</li>
<li>127.0.0.3</li>
<li>127.0.0.4</li>
</ul>
<p>四台服务器的Splash均通过dockers的splash镜像在端口：8050开启服务。<br>选择任意一台带有公网IP的主机来配置负载均衡。</p>
<p>首先在服务器安装Nginx。</p>
<p>修改Nginx的配置文件nginx.conf，添加如下内容：</p>
<pre><code>http {
    upstream splash {  # 服务器集群名为splash
        least_conn;  
        # 代表最少链接负载均衡，去掉此行将使用默认的轮询策略实现负载均衡
        # 若使用ip_hash，此方法确保同一服务器响应请求，此方法适合有状态的服务。
        # Splash不需要应用此设置。
        server 127.0.0.1:8050;
        # 还可以添加weight参数设置权值，权值越高分配到的请求越多。
        server 127.0.0.2:8050;
        server 127.0.0.3:8050;
        server 127.0.0.4:8050;
    }
    server {
        listen 8050;
        location / {
            proxy_pass http://splash;
            # 设置下面两行来进行用户认真。
            auth_basic &quot;Restricted&quot;;
            auth_baseic_user_file /etc/nginx/conf.d/.htpasswd;
        }
    }
}</code></pre><p>上面用户认证的用户名和密码配置放置在 /etc/nginx/conf.d 目录下，我们需要使用htpasswd命令创建。</p>
<p>例如，创建一个用户名为admin的文件，相关命令如下：</p>
<pre><code>htpasswd -c .htpasswd admin</code></pre><p>之后输入两次密码即可。</p>
<p>配置完成后需要重启Nginx服务。</p>
<p>测试文件在</p>
<pre><code>./test_load_balance.py</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.jiangyue0013.com/2019/06/12/初识Spalash/" data-id="cjxv157uo0015j4738kcotfnw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Queryset/">Queryset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Leetcode/" style="font-size: 10px;">Leetcode</a> <a href="/tags/Queryset/" style="font-size: 10px;">Queryset</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/django/" style="font-size: 16.67px;">django</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/爬虫/" style="font-size: 13.33px;">爬虫</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/08/从Django部署中学到的/">从Django部署中学到的</a>
          </li>
        
          <li>
            <a href="/2019/07/03/升级python版本和搭建环境/">&#39;升级python版本和搭建环境&#39;</a>
          </li>
        
          <li>
            <a href="/2019/07/02/运行Django项目出现RuntimeError错误的解决方法。/">&#39;运行Django项目出现RuntimeError错误的解决方法。&#39;</a>
          </li>
        
          <li>
            <a href="/2019/07/02/八大排序算法使用python实现/">&#39;八大排序算法使用python实现&#39;</a>
          </li>
        
          <li>
            <a href="/2019/06/30/Django中Queryset的使用（一）/">&#39;Django中Queryset的使用（一）&#39;</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Jiang Yue<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>